/* encoder.c (fixed for pointer & encode API) */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
/* add these near the top with other includes */
#include "PLMN-IdentityInfo.h"
#include "PLMN-Identity.h"
#include "MCC-MNC-Digit.h"
#include "MCC.h"
#include "MNC.h"

#include "asn_application.h"
#include "per_encoder.h"   /* uper_encode_to_buffer */
#include "xer_encoder.h"   /* xer_fprint */

#include "BCCH-DL-SCH-Message.h"
#include "SIB1.h"

int main(int argc, char **argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <server-ip> <port>\n", argv[0]);
        return 1;
    }
    const char *server_ip = argv[1];
    int port = atoi(argv[2]);

    /* Allocate top-level PDU */
    BCCH_DL_SCH_Message_t *pdu = calloc(1, sizeof(BCCH_DL_SCH_Message_t));
    if (!pdu) { perror("calloc pdu"); return 1; }

    /* Allocate the c1 pointer (it is a pointer type in generated headers) */
    pdu->message.present = BCCH_DL_SCH_MessageType_PR_c1;
    pdu->message.choice.c1 = calloc(1, sizeof(*pdu->message.choice.c1));
    if (!pdu->message.choice.c1) { perror("calloc c1"); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }

    /* Set c1 variant to carry SIB1 */
    pdu->message.choice.c1->present = BCCH_DL_SCH_MessageType__c1_PR_systemInformationBlockType1;

    /* allocate SIB1 and attach (the choice structure contains a pointer to SIB1) */
    pdu->message.choice.c1->choice.systemInformationBlockType1 = calloc(1, sizeof(SIB1_t));
    if (!pdu->message.choice.c1->choice.systemInformationBlockType1) {
        perror("calloc sib1");
        ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu);
        return 1;
    }
    SIB1_t *sib1 = pdu->message.choice.c1->choice.systemInformationBlockType1;

/* ===== BEGIN SIB1 population block (exact types used) ===== */

/* use the existing sib1 variable (do NOT redeclare it) */
/* SIB1_t *sib1 = pdu->message.choice.c1->choice.systemInformationBlockType1; */

/* Ensure cellSelectionInfo exists and set q_RxLevMin */
if (!sib1->cellSelectionInfo) {
    sib1->cellSelectionInfo = calloc(1, sizeof(*sib1->cellSelectionInfo));
    if (!sib1->cellSelectionInfo) {
        perror("calloc cellSelectionInfo");
        ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu);
        return 1;
    }
}
sib1->cellSelectionInfo->q_RxLevMin = -70;

/* Allocate one PLMN_IdentityInfo and one PLMN_Identity */
struct PLMN_IdentityInfo *plmnInfo = calloc(1, sizeof(*plmnInfo));
if (!plmnInfo) { perror("calloc plmnInfo"); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }

struct PLMN_Identity *plmn = calloc(1, sizeof(*plmn));
if (!plmn) { perror("calloc plmn"); free(plmnInfo); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }

/* Fill MNC digits (example MNC = 260 -> digits 2,6,0) */
MCC_MNC_Digit_t *digit;

/* digit 2 */
digit = calloc(1, sizeof(*digit));
if (!digit) { perror("calloc digit"); free(plmn); free(plmnInfo); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }
*digit = 2;
ASN_SEQUENCE_ADD(&plmn->mnc.list, digit);

/* digit 6 */
digit = calloc(1, sizeof(*digit));
*digit = 6;
ASN_SEQUENCE_ADD(&plmn->mnc.list, digit);

/* digit 0 */
digit = calloc(1, sizeof(*digit));
*digit = 0;
ASN_SEQUENCE_ADD(&plmn->mnc.list, digit);

/* Optionally fill MCC (example MCC = 310 -> digits 3,1,0) */
MCC_t *mcc = calloc(1, sizeof(*mcc));
if (mcc) {
    MCC_MNC_Digit_t *md;
    md = calloc(1, sizeof(*md)); *md = 3; ASN_SEQUENCE_ADD(&mcc->list, md);
    md = calloc(1, sizeof(*md)); *md = 1; ASN_SEQUENCE_ADD(&mcc->list, md);
    md = calloc(1, sizeof(*md)); *md = 0; ASN_SEQUENCE_ADD(&mcc->list, md);
    plmn->mcc = mcc; /* attach optional mcc pointer */
}

/* Add the PLMN_Identity into the PLMN_IdentityInfo.plmn_IdentityList */
ASN_SEQUENCE_ADD(&plmnInfo->plmn_IdentityList.list, plmn);

/* Add the PLMN_IdentityInfo into sib1->cellAccessRelatedInfo.plmn_IdentityInfoList */
ASN_SEQUENCE_ADD(&sib1->cellAccessRelatedInfo.plmn_IdentityInfoList.list, plmnInfo);

/* ===== END SIB1 population block ===== */


   The generated PLMN_IdentityInfoList_t is an A_SEQUENCE_OF,

    /* XER dump (human readable) */
    fprintf(stderr, "\n----- XER of constructed PDU -----\n");
    xer_fprint(stderr, &asn_DEF_BCCH_DL_SCH_Message, pdu);

    /* PER (UPER) encode: note return type is asn_enc_rval_t */
    uint8_t buffer[8192];
    
    if (ec.encoded == -1) {
        fprintf(stderr, "PER encoding failed\n");
        ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu);
        return 1;
    }
    ssize_t encoded_bits = ec.encoded; /* number of bits encoded */
    size_t encoded_bytes = (encoded_bits + 7) / 8;
    fprintf(stderr, "PER encoded %zu bytes (%zd bits)\n", encoded_bytes, encoded_bits);

    /* TCP send: connect */
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) { perror("socket"); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }
    struct sockaddr_in srv = {0};
    srv.sin_family = AF_INET;
    srv.sin_port = htons(port);
    if (inet_pton(AF_INET, server_ip, &srv.sin_addr) != 1) { perror("inet_pton"); close(sock); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }

    if (connect(sock, (struct sockaddr*)&srv, sizeof(srv)) < 0) { perror("connect"); close(sock); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }

    uint32_t netlen = htonl((uint32_t)encoded_bytes);
    if (write(sock, &netlen, sizeof(netlen)) != sizeof(netlen)) { perror("write len"); close(sock); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }

    ssize_t sent = 0;
    while ((size_t)sent < encoded_bytes) {
        ssize_t w = write(sock, buffer + sent, encoded_bytes - sent);
        if (w <= 0) { perror("write payload"); close(sock); ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu); return 1; }
        sent += w;
    }
    fprintf(stderr, "Sent %zu bytes to %s:%d\n", encoded_bytes, server_ip, port);

    close(sock);
    ASN_STRUCT_FREE(asn_DEF_BCCH_DL_SCH_Message, pdu);
    return 0;
}

